\chapter{Decisões de Projecto}

Numa primeira abordagem ao projecto, foi planeada a implementação de forwarding de dados permitindo resolver conflitos de dados e técnicas de predição dinâmica de saltos com base em Branch Prediction Buffers(BPB) e Branch Target Buffers(BTB).

A primeira versão implementada consistia em forwarding de dados com BTB contudo esta arquitectura implicava um aumento do caminho crítico do processador que a nosso ver em termos de performance não trazia benefícios ao nível do tempo de execução (Código relativo à BTB está no ficheiro BTB.vhd).

Na segunda e última versão, transitou-se para uma arquitectura com uma BPB no andar de ID\&RF permitindo minimizar alguns problemas dos associados à BTB como o elevado caminho critíco e saltos incondicionais são previstos com uma certeza de 100\% uma vez que já foi feito o decode da instrução. Adicionalmente foi considerado a existência de delayed branches, ou seja, é executada a instrução que se segue ao salto quer este seja \textit{taken} ou \textit{not-taken}. 
Assim no caso de a predição do salto ser incorrecta apenas é necessário introduzir um stall no pipeline (caso BPB no andar de ID com delay slot). 

Esta última consideração transfere a responsabilidade da utilização do delay slot do programador para o compilador sendo este capaz ou não de encontrar uma instrução válida para colocar no delay slot.

Na secção Estatísticas e Resultados apresentam-se os resultados dos testes realizados no laboratório e um outro teste adicional.

\chapter{Conflitos de Dados}

Um dos principais problemas na execução de programas em processadores com desenvolvimento em \textit{pipeline} é a existência de dependências de dados (registos) entre instruções sequenciais. Uma instrução que necessite dos resultados produzidos pela instrução no andar à sua frente terá que ser "atrasada", com recurso a stalls (instrução \textit{nop}), até os resultados estejam disponiveis para leitura. 

Para resolver estes problemas de dados é utilizada a técnica de hardware de \textit{forwarding} de dados. Esta técnica consistem em passar os dados produzidos pela instrução actualmente em execução para o andar de pipeline anterior caso exista um Conflito de Dados (\textit{Data Hazard}).

Os diferentes tipos de conflitos encontram-se descritos na tabela \ref{conf}.

\begin{table}[H]
	\begin{center}
		\makebox[\textwidth][c]{\includegraphics[clip, keepaspectratio=true, scale=0.8]{./images/conflitos.png}}
		\caption{Tipos de Conflitos.}
		\label{conf}
	\end{center}
\end{table}

Aplicado à arquitectura do $\mu$RISC apenas é possível obter conflitos do tipo Read-After-Write (RAW) uma vez que a esta arquitectura está associada execução em ordem ao contrário de nas arquitecturas com Tomasulo onde é feita execução fora de ordem após o \textit{dispatch} das instruções permitindo assim eliminar conflitos  Write-After-Read (WAR) quando é feito o \textit{issue} e \textit{dispatch} de instruções para as estações de reserva e Write-After-Write (WAW), também aplicados ao Tomasulo, quando é realizada a escrita no \textit{Common Data Bus} (CDB).

Na arquitectura desenvolvida foi utilizada a técnica de \textit{forwarding} de dados "apanhando" dos sinais de saídas das unidades funcionais e direccionando-as para o início do andar anterior com recurso a \textit{Multiplexers}.

O controlo dos sinais de selecção destes muxes é feito no bloco \textit{DataHazardUnit.vhd} onde é feita a seguinte verificação:
\begin{enumerate}
	\item Comparação entre os registos RA e RB (registos de leitura) e com o registo de destino (registo de escrita)
	\item Se o \textit{id} dos registos forem iguais é um sinal prematuro de que será necessário fazer forwarding
	\item De seguida é feita a verificação da operação. Se for uma instrução válida é a confirmação de que forward é necessário. A verificação da operação deve-se à possibilidade de colisão entre o \textit{OPCODE} de uma instrução com o valor de uma constante.
	\item É então "enviado" o sinal de selecção para a mux correcta permitindo assim executar a instrução presente no andar de ID\&RF sem ser preciso introduzir um stall no \textit{pipeline}.
\end{enumerate}

Na figura \ref{forward} está a arquitectura com o forward de dados. Este forward consistem apanhar os sinais da Unidade Lógico-Aritmética, Unidade de Constantes e saída da Memória para o andar de pipeline anterior.

\begin{figure}[H]
	\begin{center}
		\makebox[\textwidth][c]{\includegraphics[clip, keepaspectratio=true, scale=0.45]{./images/forward.png}}
		\caption{Forward de Dados.}
		\label{forward}
	\end{center}
\end{figure}

Nota: Para manter a simplicidade do esquema foram eliminados sinais presentes no pipeline.
